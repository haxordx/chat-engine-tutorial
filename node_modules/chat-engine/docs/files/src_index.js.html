<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/index.js - OpenChatFramework</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="OpenChatFramework" src="../assets/css/logo.png" style="max-height: 65%;" title="OpenChatFramework">
            OpenChatFramework
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.0.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Chat", "classes/Emitter", "classes/Me", "classes/OCF", "classes/OpenChatFramework", "classes/RootEmitter", "classes/User"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/Chat.html">Chat</a></li>
	                            <li><a href="../classes/Emitter.html">Emitter</a></li>
	                            <li><a href="../classes/Me.html">Me</a></li>
	                            <li><a href="../classes/OCF.html">OCF</a></li>
	                            <li><a href="../classes/OpenChatFramework.html">OpenChatFramework</a></li>
	                            <li><a href="../classes/RootEmitter.html">RootEmitter</a></li>
	                            <li><a href="../classes/User.html">User</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>src/index.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
&quot;use strict&quot;;


// Allows us to create and bind to events. Everything in OCF is an event
// emitter
const EventEmitter2 = require(&#x27;eventemitter2&#x27;).EventEmitter2;

// import the rltm.js library from a sister directory
// @todo include this as module
const Rltm = require(&#x27;rltm&#x27;);

// allows a synchronous execution flow. 
const waterfall = require(&#x27;async/waterfall&#x27;);

/**
* Global object used to create an instance of OCF.
*
* @class OpenChatFramework
* @constructor
* @param {Object} foo Argument 1
* @param config.rltm {Object} OCF is based off PubNub [rltm.js](https://github.com/pubnub/rltm.js) which lets you switch between PubNub and Socket.io just by changing your configuration. Check out [the rltm.js docs](https://github.com/pubnub/rltm.js) for more information.
* @param config.globalChannel {String} his is the global channel that all clients are connected to automatically. It&#x27;s used for global announcements, global presence, etc.
* @return {Object} Returns an instance of OCF
*/

const create = function(config) {

    let OCF = false;

    /**
    * Configures an event emitter that other OCF objects inherit. Adds shortcut methods for 
    * &#x60;&#x60;&#x60;this.on()&#x60;&#x60;&#x60;, &#x60;&#x60;&#x60;this.emit()&#x60;&#x60;&#x60;, etc. 
    *
    * @class RootEmitter
    * @constructor
    */
    class RootEmitter {

        constructor() {

            // create an ee2 
            this.emitter = new EventEmitter2({
              wildcard: true,
              newListener: true,
              maxListeners: 50,
              verboseMemoryLeak: true
            });

            // we bind to make sure wildcards work 
            // https://github.com/asyncly/EventEmitter2/issues/186
            this.emit = this.emitter.emit.bind(this.emitter);            

            /**
            * Listen for a specific event and fire a callback when it&#x27;s emitted
            *
            * @method on
            * @param {String} event The event name
            * @param {Function} callback The function to run when the event is emitted 
            */    
            this.on = this.emitter.on.bind(this.emitter);
     
            /**
            * Listen for any event on this object and fire a callback when it&#x27;s emitted
            *
            * @method onAny
            * @param {Function} callback The function to run when any event is emitted. First parameter is the event name and second is the payload.
            */
            this.onAny = this.emitter.onAny.bind(this.emitter);

            /**
            * Listen for an event and only fire the callback a single time
            *
            * @method once
            * @param {String} event The event name
            * @param {Function} callback The function to run once 
            */
            this.once = this.emitter.once.bind(this.emitter);

        }

    }

    /**
    * An OCF generic emitter that supports plugins and forwards
    * events to a global emitter.
    *
    * @class Emitter
    * @constructor
    * @extends RootEmitter
    */
    class Emitter extends RootEmitter {

        constructor() {

            super();
            
            // emit an event from this object
            this.emit = (event, data) =&gt; {

                // all events are forwarded to OCF object
                // so you can globally bind to events with OCF.on()
                OCF.emit(event, data);
                
                // send the event from the object that created it
                this.emitter.emit(event, data);

            }

            // assign the list of plugins for this scope
            this.plugins = [];
            
            // bind a plugin to this object
            this.plugin = function(module) {

                this.plugins.push(module);

                // returns the name of the class
                let className = this.constructor.name;

                // see if there are plugins to attach to this class
                if(module.extends &amp;&amp; module.extends[className]) {

                    // attach the plugins to this class 
                    // under their namespace
                    OCF.addChild(this, module.namespace, 
                        new module.extends[className]);

                    // if the plugin has a special construct function
                    // run it
                    if(this[module.namespace].construct) {
                        this[module.namespace].construct();
                    }

                }


            }

        }

    }

    /**
    * This is the root {{#crossLink &quot;Chat&quot;}}{{/crossLink}} class that represents a chat room
    *
    * @class Chat
    * @constructor
    * @param {String} channel The channel name for the Chat
    * @extends Emitter
    */
    class Chat extends Emitter {

        constructor(channel) {

            super();

            /**
            * The channel name for this {{#crossLink &quot;Chat&quot;}}{{/crossLink}}
            *
            * @property channel
            * @type String
            */
            this.channel = channel;

            /**
            * A list of users in this {{#crossLink &quot;Chat&quot;}}{{/crossLink}}. Automatically kept in sync,
            * Use &#x60;&#x60;&#x60;Chat.on(&#x27;$ocf.join&#x27;)&#x60;&#x60;&#x60; and related events to get notified when this changes
            *
            * @property users
            * @type Object
            */
            this.users = {};

            // this.room is our rltm.js connection 
            this.room = OCF.rltm.join(this.channel);

            // whenever we get a message from the network 
            // run local broadcast message
            this.room.on(&#x27;message&#x27;, (uuid, data) =&gt; {

                // all messages are in format [event_name, data]
                this.broadcast(data.message[0], data.message[1]);

            });

            // forward user join events
            this.room.on(&#x27;join&#x27;, (uuid, state) =&gt; {
                
                let user = this.createUser(uuid, state);

                /**
                * Broadcast that a {{#crossLink &quot;User&quot;}}{{/crossLink}} has joined the room
                *
                * @event $ocf.join
                * @param {Object} payload.user The {{#crossLink &quot;User&quot;}}{{/crossLink}} that came online
                */     
                this.broadcast(&#x27;$ocf.join&#x27;, {
                    user: user
                });

            });

            // forward user state change events
            this.room.on(&#x27;state&#x27;, (uuid, state) =&gt; {
                this.userUpdate(uuid, state)
            });

            // forward user leaving events
            this.room.on(&#x27;leave&#x27;, (uuid) =&gt; {
                this.userLeave(uuid);
            });

            // forward user leaving events
            this.room.on(&#x27;disconnect&#x27;, (uuid) =&gt; {
                this.userDisconnect(uuid);
            });

            // get a list of users online now
            this.room.here().then((occupants) =&gt; {

                // for every occupant, create a model user
                for(let uuid in occupants) {
                    // and run the join functions
                    this.createUser(uuid, occupants[uuid], true);
                }

            }, (err) =&gt; {
                throw new Error(
                    &#x27;There was a problem fetching here.&#x27;, err);
            });

        }

        /**
        * Execute a function when network connection has been made and {{#crossLink &quot;Chat&quot;}}{{/crossLink}} is ready
        *
        * @method ready
        * @param {Function} callback Function to execute when connection is ready
        */
        ready(fn) {
            this.room.ready(fn);
        }

        /**
        * Send events to other clients in this {{#crossLink &quot;User&quot;}}{{/crossLink}}. 
        * Events are broadcast over the network  and all events are made 
        * on behalf of {{#crossLink &quot;Me&quot;}}{{/crossLink}}
        *
        * @method send
        * @param {String} event The event name
        * @param {Object} data The event payload object
        */
        send(event, data) {

            // create a standardized payload object 
            let payload = {
                data: data,            // the data supplied from params
                sender: OCF.me.uuid,   // my own uuid
                chat: this,            // an instance of this chat 
            };

            // run the plugin queue to modify the event
            this.runPluginQueue(&#x27;send&#x27;, event, (next) =&gt; {
                next(null, payload);
            }, (err, payload) =&gt; {

                // remove chat otherwise it would be serialized
                // instead, it&#x27;s rebuilt on the other end. 
                // see this.broadcast
                delete payload.chat; 

                // publish the event and data over the configured channel
                this.room.publish({
                    message: [event, payload],
                    channel: this.channel
                });

            });

        }

        /**
        * @private
        * Broadcasts an event locally to all listeners.
        *
        * @method broadcast
        * @param {String} event The event name
        * @param {Object} payload The event payload object
        */
        broadcast(event, payload) {

            // restore chat in payload
            if(!payload.chat) {
                payload.chat = this;   
            }

            // turn a uuid found in payload.sender to a real user
            if(payload.sender &amp;&amp; OCF.users[payload.sender]) {
                payload.sender = OCF.users[payload.sender];
            }

            // let plugins modify the event
            this.runPluginQueue(&#x27;broadcast&#x27;, event, (next) =&gt; {
                next(null, payload);
            }, (err, payload) =&gt; {

                // emit this event to any listener
                this.emit(event, payload);

            });

        }

        /**
        * @private
        * Add a user to the {{#crossLink &quot;Chat&quot;}}{{/crossLink}}, creating it if it doesn&#x27;t already exist.
        *
        * @method createUser
        * @param {String} uuid The user uuid
        * @param {Object} state The user initial state
        * @param {Boolean} broadcast Force a broadcast that this user is online
        */
        createUser(uuid, state, broadcast = false) {

            // Ensure that this user exists in the global list
            // so we can reference it from here out
            OCF.users[uuid] = OCF.users[uuid] || new User(uuid);

            // Add this chatroom to the user&#x27;s list of chats
            OCF.users[uuid].addChat(this, state);

            // broadcast the join event over this chatroom
            if(!this.users[uuid] || broadcast) {

                /**
                * Broadcast that a {{#crossLink &quot;User&quot;}}{{/crossLink}} has come online
                *
                * @event $ocf.online
                * @param {Object} payload.user The {{#crossLink &quot;User&quot;}}{{/crossLink}} that came online
                */     
                this.broadcast(&#x27;$ocf.online&#x27;, {
                    user: OCF.users[uuid]
                });

            }

            // store this user in the chatroom
            this.users[uuid] = OCF.users[uuid];

            // return the instance of this user
            return OCF.users[uuid];

        }

        /**
        * @private
        * Update a user&#x27;s state within this {{#crossLink &quot;Chat&quot;}}{{/crossLink}}.
        *
        * @method userUpdate
        * @param {String} uuid The {{#crossLink &quot;User&quot;}}{{/crossLink}} uuid
        * @param {Object} state State to update for the user
        */
        userUpdate(uuid, state) {

            // ensure the user exists within the global space
            OCF.users[uuid] = OCF.users[uuid] || new User(uuid);

            // if we don&#x27;t know about this user
            if(!this.users[uuid]) {
                // do the whole join thing
                this.createUser(uuid, state);
            }

            // update this user&#x27;s state in this chatroom
            this.users[uuid].assign(state, this);

            /**
            * Broadcast that a {{#crossLink &quot;User&quot;}}{{/crossLink}} has changed state
            *
            * @event $ocf.state
            * @param {Object} payload.user The {{#crossLink &quot;User&quot;}}{{/crossLink}} that changed state
            * @param {Object} payload.state The new user state for this &#x60;&#x60;&#x60;Chat&#x60;&#x60;&#x60;
            */           
            this.broadcast(&#x27;$ocf.state&#x27;, {
                user: this.users[uuid],
                state: this.users[uuid].state(this)
            });

        }

        /**
         * Leave from the {{#crossLink &quot;Chat&quot;}}{{/crossLink}} on behalf of {{#crossLink &quot;Me&quot;}}{{/crossLink}}
         *
         * @method leave
         */
        leave() {

            // disconnect from the chat
            this.room.unsubscribe().then(() =&gt; {
                // should get caught on as network event
            });

        }

        /**
         * @private
         * Perform updates when a user has left the {{#crossLink &quot;Chat&quot;}}{{/crossLink}}.
         *
         * @method leave
         */
        userLeave(uuid) {

            // make sure this event is real, user may have already left
            if(this.users[uuid]) {

                // if a user leaves, broadcast the event
                this.broadcast(&#x27;$ocf.leave&#x27;, this.users[uuid]);
                this.broadcast(&#x27;$ocf.offline&#x27;, this.users[uuid]);

                // remove the user from the local list of users
                delete this.users[uuid];

                // we don&#x27;t remove the user from the global list, 
                // because they may be online in other channels

            } else {

                // that user isn&#x27;t in the user list
                // we never knew about this user or they already left

                // console.log(&#x27;user already left&#x27;);
            }
        }

        /**
        * @private
        * Fired when a user disconnects from the {{#crossLink &quot;Chat&quot;}}{{/crossLink}}
        *
        * @method userDisconnect
        * @param {String} uuid The uuid of the {{#crossLink &quot;Chat&quot;}}{{/crossLink}} that left
        */
        userDisconnect(uuid) {

            // make sure this event is real, user may have already left
            if(this.users[uuid]) {

                /**
                * A {{#crossLink &quot;User&quot;}}{{/crossLink}} has been disconnected from the &#x60;&#x60;&#x60;Chat&#x60;&#x60;&#x60;
                *
                * @event $ocf.disconnect
                * @param {Object} User The {{#crossLink &quot;User&quot;}}{{/crossLink}} that disconnected
                */     
                this.broadcast(&#x27;$ocf.disconnect&#x27;, this.users[uuid]);

                /**
                * A {{#crossLink &quot;User&quot;}}{{/crossLink}} has gone offline
                *
                * @event $ocf.offline
                * @param {Object} User The {{#crossLink &quot;User&quot;}}{{/crossLink}} that has gone offline
                */  
                this.broadcast(&#x27;$ocf.offline&#x27;, this.users[uuid]);

            }

        }

        /**
        * @private
        * Load plugins and attach a queue of functions to execute before and
        * after events are broadcast or received.
        *
        * @method runPluginQueue
        * @param {String} location Where in the middleeware the event should run (send, broadcast)
        * @param {String} event The event name
        * @param {String} first The first function to run before the plugins have run
        * @param {String} last The last function to run after the plugins have run
        */
        runPluginQueue(location, event, first, last) {

            // this assembles a queue of functions to run as middleware
            // event is a broadcasted event key
            let plugin_queue = [];

            // the first function is always required
            plugin_queue.push(first);

            // look through the configured plugins
            for(let i in this.plugins) {

                // if they have defined a function to run specifically 
                // for this event
                if(this.plugins[i].middleware 
                    &amp;&amp; this.plugins[i].middleware[location] 
                    &amp;&amp; this.plugins[i].middleware[location][event]) {

                    // add the function to the queue
                    plugin_queue.push(
                        this.plugins[i].middleware[location][event]);
                }

            }

            // waterfall runs the functions in assigned order
            // waiting for one to complete before moving to the next
            // when it&#x27;s done, the &#x60;&#x60;&#x60;last&#x60;&#x60;&#x60; parameter is called
            waterfall(plugin_queue, last);

        }

        /**
        * @private
        * Set the state for {{#crossLink &quot;Me&quot;}}{{/crossLink}} within this {{#crossLink &quot;User&quot;}}{{/crossLink}}. 
        * Broadcasts the &#x60;&#x60;&#x60;$ocf.state&#x60;&#x60;&#x60; event on other clients
        *
        * @method setState
        * @param {Object} state The new state {{#crossLink &quot;Me&quot;}}{{/crossLink}} will have within this {{#crossLink &quot;User&quot;}}{{/crossLink}}
        */
        setState(state) {

            // handy method to set state of user without touching rltm
            this.room.setState(state);
        }

    };

    /**
    * This is our User class which represents a connected client
    *
    * @class User
    * @constructor
    * @extends Emitter
    */
    class User extends Emitter {

        constructor(uuid, state = {}, chat = OCF.globalChat) {

            super();

            /**
            * the User&#x27;s uuid. This is public id exposed to the network.
            *
            * @property uuid
            * @type String
            */
            this.uuid = uuid;

            /**
            * keeps account of user state in each channel
            *
            * @property states
            * @type Object
            */
            this.states = {};

            /**
            * keep a list of chatrooms this user is in
            *
            * @property chats
            * @type Object
            */
            this.chats = {};

            /**
            * every user has a couple personal rooms we can connect to
            * feed is a list of things a specific user does that 
            * many people can subscribe to
            *
            * @property feed
            * @type Chat
            */
            this.feed = new Chat(
                [OCF.globalChat.channel, &#x27;feed&#x27;, uuid].join(&#x27;.&#x27;));

            /**
            * direct is a private channel that anybody can publish to
            * but only the user can subscribe to
            * this permission based system is not implemented yet
            *
            * @property direct
            * @type Chat
            */
            this.direct = new Chat(
                [OCF.globalChat.channel, &#x27;direct&#x27;, uuid].join(&#x27;.&#x27;));

            // if the user does not exist at all and we get enough 
            // information to build the user
            if(!OCF.users[uuid]) {
                OCF.users[uuid] = this;
            }

            // update this user&#x27;s state in it&#x27;s created context
            this.assign(state, chat)
            
        }

        /**
        * get the user&#x27;s state in a chatroom
        *
        * @method state
        * @param {Chat} chat Chatroom to retrieve state from
        */
        state(chat = OCF.globalChat) {
            return this.states[chat.channel] || {};
        }

        /**
        * update the user&#x27;s state in a specific chatroom
        *
        * @method update
        * @param {Object} state The new state for the user
        * @param {Chat} chat Chatroom to retrieve state from
        */
        update(state, chat = OCF.globalChat) {
            let chatState = this.state(chat) || {};
            this.states[chat.channel] = Object.assign(chatState, state);
        }

        /**
        * @private
        * this is only called from network updates
        *
        * @method assign
        */
        assign(state, chat) {
            this.update(state, chat);
        }

        /**
        * @private
        * adds a chat to this user
        *
        * @method addChat
        */
        addChat(chat, state) {

            // store the chat in this user object
            this.chats[chat.channel] = chat;
        
            // updates the user&#x27;s state in that chatroom
            this.assign(state, chat);
        }

    }

    /**
    * Represents the client connection as a {{#crossLink &quot;User&quot;}}{{/crossLink}}. 
    * Has the ability to update it&#x27;s state on the network. An instance of 
    * {{#crossLink &quot;Me&quot;}}{{/crossLink}} is returned by the &#x60;&#x60;&#x60;OCF.connect()&#x60;&#x60;&#x60;
    * method. 
    *
    * @class Me
    * @constructor
    * @param {String} uuid The uuid of this user
    * @extends User
    */
    class Me extends User {

        constructor(uuid) {

            // call the User constructor
            super(uuid);

        }

        // assign updates from network
        assign(state, chat) {
            // we call &quot;update&quot; because calling &quot;super.assign&quot;
            // will direct back to &quot;this.update&quot; which creates
            // a loop of network updates
            super.update(state, chat);
        }

        /**
        * Update this user state over the network
        *
        * @method update
        * @param {Object} state The new state for {{#crossLink &quot;Me&quot;}}{{/crossLink}}
        * @param {Chat} chat An instance of the {{#crossLink &quot;Chat&quot;}}{{/crossLink}} where state will be updated.
        * Defaults to &#x60;&#x60;&#x60;OCF.globalChat&#x60;&#x60;&#x60;.
        */
        update(state, chat = OCF.globalChat) {

            // run the root update function
            super.update(state, chat);

            // publish the update over the global channel
            chat.setState(state);

        }

    }

    /**
     * Provides the base Widget class...
     *
     * @class OCF
     */
    const init = function() {

        // Create the root OCF object
        OCF = new RootEmitter;

        // stores config vars
        OCF.config = config || {};

        // set a default global channel if none is set
        OCF.config.globalChannel = OCF.config.globalChannel || &#x27;ocf-global&#x27;;

        // create a global list of known users
        OCF.users = {};

        // define our global chatroom all users join by default
        OCF.globalChat = false;

        // define the user that this client represents
        OCF.me = false;

        // store a reference to the rltm.js networking library
        OCF.rltm = false;

        /**
        * connect to realtime service and create instance of {{#crossLink &quot;Me&quot;}}{{/crossLink}} 
        *
        * @method connect
        * @param {String} uuid The uuid for {{#crossLink &quot;Me&quot;}}{{/crossLink}}
        * @param {Object} state The initial state for {{#crossLink &quot;Me&quot;}}{{/crossLink}}
        * @return {Me} me an instance of me
        */
        OCF.connect = function(uuid, state) {

            // make sure the uuid is set for this client 
            if(!uuid) {
                throw new Error(&#x27;You must supply a uuid as the &#x27; + 
                    &#x27;first parameter when connecting.&#x27;);
            }

            // this creates a user known as Me and 
            // connects to the global chatroom
            this.config.rltm.config.uuid = uuid;
            this.config.rltm.config.state = state;

            // configure the rltm plugin with the params set in config method
            this.rltm = new Rltm(config.rltm);

            // create a new chat to use as globalChat
            this.globalChat = new Chat(config.globalChannel);

            // create a new user that represents this client
            this.me = new Me(uuid);

            // create a new instance of Me using input parameters
            this.globalChat.createUser(uuid, state);

            // return me
            return this.me;

            // client can access globalChat through OCF.globalChat

        };

        // our exported classes
        OCF.Chat = Chat;
        OCF.User = User;

        // add an object as a subobject under a namespoace
        OCF.addChild = (ob, childName, childOb) =&gt; {

            // assign the new child object as a property of parent under the
            // given namespace
            ob[childName] = childOb;

            // the new object can use &#x60;&#x60;&#x60;this.parent&#x60;&#x60;&#x60; to access 
            // the root class
            childOb.parent = ob;

            // the new object can use &#x60;&#x60;&#x60;this.OCF&#x60;&#x60;&#x60; to get the global config
            childOb.OCF = this;
            
        }

        return OCF;

    }

    // return an instance of OCF
    return init();

}

// export the OCF api
module.exports = {
    plugin: {},  // leave a spot for plugins to exist
    create: create
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
